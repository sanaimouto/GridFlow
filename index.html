<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GridFlow - v2.3 å®Œæ•´ç‰ˆ</title>
    <style>
        * { box-sizing: border-box; }

        :root {
            --primary-color: #2563eb;
            --bg-color: #f8fafc;
            --panel-bg: #ffffff;
            --border-color: #e2e8f0;
            --text-color: #1e293b;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .header { text-align: center; margin-bottom: 20px; }
        h1 { margin: 0 0 10px 0; font-size: 1.8rem; }
        p.subtitle { margin: 0; color: #64748b; font-size: 0.95rem; }

        .main-container {
            display: flex;
            gap: 20px;
            width: 100%;
            max-width: 1200px;
            align-items: flex-start;
            flex-wrap: wrap;
        }

        .sidebar {
            flex: 1;
            min-width: 300px;
            background: var(--panel-bg);
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 20px;
        }

        .workspace {
            flex: 2;
            min-width: 300px;
            background: var(--panel-bg);
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 500px;
        }

        .control-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-weight: 600; font-size: 0.9rem; }
        
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-weight: normal;
            background: #f1f5f9;
            padding: 8px;
            border-radius: 6px;
        }
        .checkbox-label input { width: auto; }

        select, input[type="number"], input[type="color"] {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 1rem;
        }

        .btn-group { display: grid; gap: 10px; margin-top: 20px; }

        button {
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary { background-color: var(--primary-color); color: white; }
        .btn-primary:hover { background-color: #1d4ed8; }
        .btn-primary:disabled { background-color: #94a3b8; cursor: not-allowed; }

        .btn-secondary { background-color: #e2e8f0; color: var(--text-color); }
        .btn-secondary:hover { background-color: #cbd5e1; }

        .btn-upload {
            background-color: #10b981;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .btn-upload:hover { background-color: #059669; }

        #interactive-area {
            background-color: #ffffff; 
            padding: 20px; 
            border: 2px dashed #cbd5e1;
            width: 100%;
            min-height: 400px;
            display: flex;
            flex-wrap: wrap; 
            align-content: flex-start;
            transition: gap 0.2s;
            position: relative;
        }

        .img-card {
            position: relative;
            cursor: grab;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #eee;
            transition: transform 0.1s;
        }
        
        .img-card.dragging {
            opacity: 0.5;
            border: 2px dashed var(--primary-color);
            cursor: grabbing;
        }

        .img-card img {
            display: block;
            width: 100%;
            height: 100%;
            object-fit: contain;
            pointer-events: none; 
        }

        .delete-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 24px;
            height: 24px;
            background: rgba(239, 68, 68, 0.9);
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 22px;
            font-size: 16px;
            cursor: pointer;
            z-index: 20;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .img-card:hover .delete-btn { opacity: 1; }

        #renderCanvas { display: none; }
        .hidden { display: none; }
    </style>
</head>
<body>

<div class="header">
    <h1>GridFlow</h1>
    <p class="subtitle">å››è‘‰äº­ å•†å“åœ–ç‰‡åˆä½µå·¥å…· v2.3 å®Œæ•´ç‰ˆ</p>
</div>

<div class="main-container">
    <div class="sidebar">
        <div class="control-group">
            <button class="btn-upload" onclick="document.getElementById('fileInput').click()">
                <span>ğŸ“· ä¸Šå‚³åœ–ç‰‡</span>
            </button>
            <input type="file" id="fileInput" multiple accept="image/*" style="display: none;">
        </div>

        <hr style="border: 0; border-top: 1px solid #e2e8f0; margin: 20px 0;">

        <div class="control-group">
            <label>æ’åˆ—æ¨¡å¼</label>
            <select id="layoutMode">
                <option value="grid" selected>ç¶²æ ¼ (Grid)</option>
                <option value="horizontal">æ©«å‘ (Horizontal)</option>
                <option value="vertical">ç¸±å‘ (Vertical)</option>
            </select>
        </div>

        <div class="control-group" id="gridSettings">
            <label>æ¯åˆ—å¼µæ•¸ (ç¶²æ ¼æ¨¡å¼)</label>
            <input type="number" id="colCount" value="2" min="1" max="10">
            
            <div style="margin-top: 10px;">
                <label class="checkbox-label" title="è‹¥æ•¸é‡ä¸å¤ ä¸€åˆ—ï¼Œå°‡è©²åˆ—ç½®æ–¼ä¸Šæ–¹ä¸¦ç½®ä¸­">
                    <input type="checkbox" id="incompleteTop">
                    <span>å°‡æœªæ»¿çš„æ’ç½®é ‚ (å€’é‡‘å­—å¡”)</span>
                </label>
            </div>
        </div>

        <div class="control-group">
            <label>é–“è· (px)</label>
            <input type="number" id="gapSize" value="10" min="0" max="100">
        </div>

        <div class="control-group">
            <label>èƒŒæ™¯é¡è‰²</label>
            <input type="color" id="bgColor" value="#ffffff">
        </div>
        
        <div class="control-group">
             <label>è¼¸å‡ºæ ¼å¼</label>
             <select id="exportFormat">
                 <option value="image/jpeg">JPG (é©åˆç…§ç‰‡)</option>
                 <option value="image/png">PNG (ç„¡æ/é€æ˜)</option>
                 <option value="image/webp">WebP (è¼•é‡)</option>
             </select>
        </div>

        <div class="btn-group">
            <button id="downloadBtn" class="btn-primary" disabled>â¬‡ï¸ ä¸‹è¼‰åˆä½µåœ–ç‰‡</button>
            <button id="clearBtn" class="btn-secondary">ğŸ—‘ï¸ å…¨éƒ¨æ¸…ç©º</button>
        </div>
    </div>

    <div class="workspace">
        <div id="interactive-area"></div>
        <canvas id="renderCanvas"></canvas>
    </div>
</div>

<script>
    let items = []; 
    let draggedItem = null;

    const fileInput = document.getElementById('fileInput');
    const interactiveArea = document.getElementById('interactive-area');
    const layoutModeSelect = document.getElementById('layoutMode');
    const colCountInput = document.getElementById('colCount');
    const incompleteTopInput = document.getElementById('incompleteTop'); // æ–°å¢
    const gapSizeInput = document.getElementById('gapSize');
    const bgColorInput = document.getElementById('bgColor');
    const downloadBtn = document.getElementById('downloadBtn');
    const clearBtn = document.getElementById('clearBtn');
    const exportFormatSelect = document.getElementById('exportFormat');
    const canvas = document.getElementById('renderCanvas');
    const ctx = canvas.getContext('2d');
    const gridSettings = document.getElementById('gridSettings');

    // --- åˆå§‹åŒ– ---
    fileInput.addEventListener('change', handleUpload);
    
    // æ‰€æœ‰åƒæ•¸è®Šå‹•éƒ½è§¸ç™¼è¦–è¦ºæ›´æ–°
    [layoutModeSelect, colCountInput, incompleteTopInput, gapSizeInput, bgColorInput].forEach(el => {
        el.addEventListener('input', updateLayoutVisuals);
        el.addEventListener('change', updateLayoutVisuals);
    });

    layoutModeSelect.addEventListener('change', () => {
        if(layoutModeSelect.value === 'grid') gridSettings.classList.remove('hidden');
        else gridSettings.classList.add('hidden');
    });

    clearBtn.addEventListener('click', () => {
        items = [];
        renderInteractiveArea();
        fileInput.value = '';
    });

    downloadBtn.addEventListener('click', generateAndDownload);

    // --- æ‹–æ›³é‚è¼¯ ---
    interactiveArea.addEventListener('dragover', (e) => {
        e.preventDefault(); 
        if (!draggedItem) return;

        const targetCard = e.target.closest('.img-card');
        if (targetCard && targetCard !== draggedItem) {
            const children = Array.from(interactiveArea.children);
            const draggedIdx = children.indexOf(draggedItem);
            const targetIdx = children.indexOf(targetCard);
            
            if (draggedIdx < targetIdx) targetCard.after(draggedItem);
            else targetCard.before(draggedItem);
            
            // æ‹–æ›³æ™‚è‹¥é †åºæ”¹è®Šï¼Œå¯èƒ½å½±éŸ¿ç¬¬ä¸€æ’çš„è¨ˆç®—ï¼Œæ‰€ä»¥è¦å³æ™‚æ›´æ–°è¦–è¦º margin
            // ä½†ç‚ºäº†æ•ˆèƒ½ï¼Œæˆ‘å€‘å¯ä»¥ç­‰ dragend å†æ›´æ–°ï¼Œæˆ–è€…é€™è£¡ä¹Ÿæ›´æ–°
            // ç‚ºäº†å³æ™‚é è¦½æ•ˆæœï¼Œæˆ‘å€‘é€™è£¡ä¹Ÿå‘¼å«
            // æ³¨æ„ï¼šé »ç¹å‘¼å«å¯èƒ½å¾®å¡ï¼Œä½†é›»è…¦ç‰ˆé€šå¸¸æ²’å•é¡Œ
            setTimeout(updateLayoutVisuals, 0); 
        }
    });

    // --- ä¸Šå‚³èˆ‡æ¸²æŸ“ ---

    async function handleUpload(e) {
        if (!e.target.files || e.target.files.length === 0) return;
        const files = Array.from(e.target.files);
        
        try {
            const promises = files.map(file => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (evt) => {
                        resolve({ 
                            id: Math.random().toString(36).substr(2, 9),
                            src: evt.target.result 
                        });
                    };
                    reader.onerror = () => reject('åœ–ç‰‡è®€å–å¤±æ•—');
                    reader.readAsDataURL(file);
                });
            });

            const newItems = await Promise.all(promises);
            items = [...items, ...newItems];
            renderInteractiveArea();
        } catch (err) {
            console.error(err);
            alert('éƒ¨åˆ†åœ–ç‰‡ä¸Šå‚³å¤±æ•—');
        } finally {
            fileInput.value = ''; 
        }
    }

    function renderInteractiveArea() {
        interactiveArea.innerHTML = '';
        if (items.length === 0) {
            interactiveArea.innerHTML = '<p style="color:#aaa; width:100%; text-align:center; padding-top:50px; pointer-events: none;">æ‹–æ›³æˆ–é»æ“Šä¸Šå‚³åœ–ç‰‡</p>';
            downloadBtn.disabled = true;
            return;
        }
        downloadBtn.disabled = false;

        items.forEach((item) => {
            const card = document.createElement('div');
            card.className = 'img-card';
            card.draggable = true;
            card.dataset.id = item.id;
            
            const delBtn = document.createElement('div');
            delBtn.className = 'delete-btn';
            delBtn.innerHTML = 'Ã—';
            delBtn.onclick = (e) => {
                e.stopPropagation();
                items = items.filter(i => i.id !== item.id);
                renderInteractiveArea();
            };
            
            const img = document.createElement('img');
            img.src = item.src;
            
            card.appendChild(img);
            card.appendChild(delBtn);
            
            card.addEventListener('dragstart', function(e) {
                draggedItem = this;
                setTimeout(() => this.classList.add('dragging'), 0);
            });

            card.addEventListener('dragend', function() {
                this.classList.remove('dragging');
                draggedItem = null;
                synchronizeItems(); 
                updateLayoutVisuals(); // ç¢ºä¿æ¨£å¼æ­£ç¢º
            });

            interactiveArea.appendChild(card);
        });

        updateLayoutVisuals();
    }

    function synchronizeItems() {
        const currentCards = Array.from(interactiveArea.querySelectorAll('.img-card'));
        const newItems = [];
        currentCards.forEach(card => {
            const id = card.dataset.id;
            const item = items.find(i => i.id === id);
            if (item) newItems.push(item);
        });
        items = newItems;
    }

    // --- è¦–è¦ºæ§åˆ¶ (æ ¸å¿ƒæ›´æ–°ï¼šè™•ç† Margin ç½®ä¸­) ---

    function updateLayoutVisuals() {
        const mode = layoutModeSelect.value;
        const gap = parseInt(gapSizeInput.value) || 0;
        const bg = bgColorInput.value;
        const colCount = parseInt(colCountInput.value) || 2;
        const isInvert = incompleteTopInput.checked;

        interactiveArea.style.backgroundColor = bg;
        interactiveArea.style.gap = gap + 'px';

        const cards = document.querySelectorAll('.img-card');
        const total = cards.length;

        // æ¸…é™¤æ‰€æœ‰èˆŠæ¨£å¼
        cards.forEach(card => {
            card.style.width = ''; card.style.height = ''; 
            card.style.margin = ''; card.style.flexShrink = '';
        });

        if (mode === 'horizontal') {
            interactiveArea.style.flexDirection = 'row';
            interactiveArea.style.justifyContent = 'flex-start';
            interactiveArea.style.flexWrap = 'nowrap';
            interactiveArea.style.overflowX = 'auto';
            cards.forEach(card => {
                card.style.height = '200px'; card.style.width = 'auto'; card.style.flexShrink = '0';
            });

        } else if (mode === 'vertical') {
            interactiveArea.style.flexDirection = 'column';
            interactiveArea.style.alignItems = 'center';
            interactiveArea.style.flexWrap = 'nowrap';
            cards.forEach(card => {
                card.style.width = '300px'; card.style.height = 'auto';
            });

        } else if (mode === 'grid') {
            interactiveArea.style.flexDirection = 'row';
            interactiveArea.style.flexWrap = 'wrap';
            // é è¨­ Flexbox behavior: left to right.
            // æˆ‘å€‘æœƒé€é margin æ§åˆ¶ç½®ä¸­
            interactiveArea.style.justifyContent = 'center'; 
            interactiveArea.style.overflowX = 'hidden';

            const widthCalc = `calc((100% - ${gap * (colCount - 1)}px) / ${colCount})`;
            
            const remainder = total % colCount;
            
            // è™•ç†ã€Œå€’é‡‘å­—å¡”ã€çš„ç‰¹æ®Š Margin
            // åªæœ‰ç•¶ æœ‰é¤˜æ•¸ ä¸” é¤˜æ•¸ < åˆ—æ•¸ ä¸” å•Ÿç”¨äº†åŠŸèƒ½ æ™‚æ‰è™•ç†
            let firstRowOffset = 0;
            let needForceBreak = false;

            if (isInvert && remainder > 0) {
                // ç¬¬ä¸€æ’æ‡‰è©²åªæœ‰ remainder å€‹å…ƒç´ 
                // æˆ‘å€‘éœ€è¦è®“ç¬¬1å€‹å…ƒç´ å¾€å³æ¨ (margin-left)ï¼Œé”åˆ°ç½®ä¸­æ•ˆæœ
                // åç§»é‡ = (ç¸½å¯¬ - (é …ç›®å¯¬*R + é–“è·*(R-1))) / 2
                // ä½†é€™è£¡å…¶å¯¦åªè¦è£œè¶³ã€Œç¼ºå°‘çš„é …ç›®å¯¬åº¦ã€çš„ä¸€åŠ
                // ç¼ºå°‘çš„å¯¬åº¦ = (Cols - R) * (ItemWidth + Gap)
                // MarginLeft = ç¼ºå°‘å¯¬åº¦ / 2
                
                // ç°¡å–®ç®—æ³•ï¼šæ¯å€‹ç©ºä½ = 1å€‹Item + 1å€‹Gap
                // ä½†å› ç‚º CSS calc æ¯”è¼ƒè¤‡é›œï¼Œæˆ‘å€‘ç”¨ Flexbox çš„ç‰¹æ€§
                
                // ç­–ç•¥ï¼šè¨ˆç®—ç¬¬ä¸€æ’é …ç›®å¯¬åº¦ï¼Œç„¶å¾Œå°ç¬¬1å€‹é …ç›®åŠ  Margin-Leftï¼Œå°ç¬¬ R å€‹é …ç›®åŠ  Margin-Right å¼·åˆ¶æ›è¡Œ
                needForceBreak = true;
            }

            cards.forEach((card, index) => {
                card.style.width = widthCalc;
                card.style.height = 'auto';

                if (needForceBreak) {
                    // å°ç¬¬ 0 å€‹é …ç›®åŠ å·¦é‚Šè·ï¼Œè®“å®ƒç½®ä¸­
                    if (index === 0) {
                        // ç©ºç¼ºçš„æ•¸é‡
                        const emptySlots = colCount - remainder;
                        // åç§»é‡ = ç©ºç¼ºæ•¸é‡ * (100% / Cols) / 2
                        // é€™è£¡ç”¨ % æ¯”è¼ƒæº–
                        const offsetPercent = (emptySlots / colCount * 50); 
                        // ä½†é€™æ²’è€ƒæ…® gapï¼Œæ¯”è¼ƒç²—ç•¥ã€‚
                        // æ›´ç²¾æº–ï¼šç”¨ calc
                        // Margin = (EmptySlots * (CardWidth + Gap)) / 2
                        // ç”±æ–¼ CardWidth æ˜¯ calcï¼Œé€™è£¡çµ„åˆèµ·ä¾†å¤ªé•·ï¼Œæˆ‘å€‘ç”¨ç°¡å–®çš„ Flex æŠ€å·§ï¼š
                        
                        // å…¶å¯¦åªè¦å°ç¬¬ä¸€æ’ä½¿ç”¨ justify-content: center å³å¯ï¼Ÿ
                        // ä½† interactiveArea åªæœ‰ä¸€å€‹ global è¨­å®šã€‚
                        // æˆ‘å€‘å¯ä»¥ç”¨ margin-left: auto å’Œ margin-right: auto å—ï¼Ÿ
                        // ä¸è¡Œï¼Œå› ç‚ºé‚„æœ‰ gapã€‚
                        
                        // å›åˆ°æœ€ç©©çš„ margin calc
                        // CardWidth = (100% - (C-1)G)/C
                        // GapPart = G
                        // UnitWidth = CardWidth + G = (100% + G)/C
                        // Offset = EmptySlots * UnitWidth / 2
                        card.style.marginLeft = `calc(${colCount - remainder} * ((100% + ${gap}px) / ${colCount}) / 2)`;
                    }

                    // å°ç¬¬ R-1 å€‹é …ç›® (ç¬¬ä¸€æ’æœ€å¾Œä¸€å€‹) åŠ å³é‚Šè·ï¼Œå¼·åˆ¶æŠŠå¾Œé¢çš„æ“ ä¸‹å»
                    if (index === remainder - 1) {
                         card.style.marginRight = `calc(${colCount - remainder} * ((100% + ${gap}px) / ${colCount}) / 2)`;
                         // æ³¨æ„ï¼šå·¦å³ margin å„ä¸€åŠï¼ŒåŠ èµ·ä¾†å‰›å¥½å¡«æ»¿å‰©ä¸‹çš„ç©ºé–“ï¼Œ
                         // é€™æ¨£ç¬¬ R å€‹å…ƒç´ ï¼ˆindex = remainderï¼‰å°±æœƒå› ç‚ºæ²’ä½å­è€Œæ›è¡Œã€‚
                    }
                }
            });
        }
    }

    // --- Canvas è¼¸å‡º ---

    function generateAndDownload() {
        if (items.length === 0) return;
        
        const imgLoadPromises = items.map(item => {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.src = item.src;
            });
        });

        Promise.all(imgLoadPromises).then(imgObjects => {
            const mode = layoutModeSelect.value;
            const gap = parseInt(gapSizeInput.value) || 0;
            const bg = bgColorInput.value;
            const cols = parseInt(colCountInput.value);
            const isInvert = incompleteTopInput.checked;

            let drawData = [];
            let canvasW = 0, canvasH = 0;

            if (mode === 'grid') {
                const maxW = Math.max(...imgObjects.map(img => img.naturalWidth));
                const colWidth = maxW; 
                canvasW = (colWidth * cols) + (gap * (cols + 1));
                
                let currentY = gap;
                let currentIdx = 0;
                const total = imgObjects.length;
                const remainder = total % cols;

                // åˆ¤æ–·ç¬¬ä¸€æ’æ˜¯å¦ç‰¹æ®Š
                let firstRowIsSpecial = (isInvert && remainder > 0);

                while(currentIdx < total) {
                    // æ±ºå®šé€™ä¸€åˆ—æœ‰å¹¾å¼µ
                    let countInRow = cols;
                    if (currentIdx === 0 && firstRowIsSpecial) {
                        countInRow = remainder;
                    }

                    const rowImgs = imgObjects.slice(currentIdx, currentIdx + countInRow);
                    
                    // è¨ˆç®—ç½®ä¸­åç§» (Canvas é‚è¼¯)
                    const emptySlots = cols - rowImgs.length;
                    let offsetX = 0;
                    if (emptySlots > 0) {
                        offsetX = (emptySlots * (colWidth + gap)) / 2;
                    }
                    
                    const rowDims = rowImgs.map(img => {
                        const scale = colWidth / img.naturalWidth;
                        return { w: colWidth, h: img.naturalHeight * scale, img };
                    });
                    
                    const maxRowH = Math.max(...rowDims.map(d => d.h));
                    
                    rowDims.forEach((d, idx) => {
                        const x = gap + (idx * (colWidth + gap)) + offsetX;
                        drawData.push({ ...d, x, y: currentY });
                    });
                    
                    currentY += maxRowH + gap;
                    currentIdx += countInRow;
                }
                canvasH = currentY;

            } else if (mode === 'horizontal') {
                const maxHeight = Math.max(...imgObjects.map(img => img.naturalHeight));
                let currentX = gap;
                imgObjects.forEach(img => {
                    const scale = maxHeight / img.naturalHeight;
                    drawData.push({ img, x: currentX, y: gap, w: img.naturalWidth * scale, h: maxHeight });
                    currentX += (img.naturalWidth * scale) + gap;
                });
                canvasH = maxHeight + gap * 2;
                canvasW = currentX;

            } else if (mode === 'vertical') {
                const maxWidth = Math.max(...imgObjects.map(img => img.naturalWidth));
                let currentY = gap;
                imgObjects.forEach(img => {
                    const scale = maxWidth / img.naturalWidth;
                    drawData.push({ img, x: gap, y: currentY, w: maxWidth, h: img.naturalHeight * scale });
                    currentY += (img.naturalHeight * scale) + gap;
                });
                canvasW = maxWidth + gap * 2;
                canvasH = currentY;
            }

            canvas.width = canvasW;
            canvas.height = canvasH;
            ctx.fillStyle = bg;
            ctx.fillRect(0, 0, canvasW, canvasH);
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            drawData.forEach(d => {
                ctx.drawImage(d.img, d.x, d.y, d.w, d.h);
            });

            const format = exportFormatSelect.value;
            const link = document.createElement('a');
            const ext = format.split('/')[1];
            link.download = `GridFlow_${Date.now()}.${ext}`;
            link.href = canvas.toDataURL(format, 0.95);
            link.click();
        });
    }
</script>

</body>
</html>
